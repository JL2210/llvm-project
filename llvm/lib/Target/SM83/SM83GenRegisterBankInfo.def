//===- SM83GenRegisterBankInfo.def -------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by SM83RegisterBankInfo.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "sm83-gen-register-bank"

namespace llvm {

RegisterBankInfo::PartialMapping SM83GenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // GPR value
    {0, 8, SM83::GPRRegBank},   // :0
    {0, 16, SM83::GPRRegBank},  // :1
};

#define X3(X) X X X
#define PARTMAP(x) \
{&SM83GenRegisterBankInfo::PartMappings[x - PMI_Min], 1},
// ValueMappings.
RegisterBankInfo::ValueMapping SM83GenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 3-operands instructions (all binary operations should end up with one of
    // those mapping).
    // 1: GPR 8-bit value.
    X3(PARTMAP(PMI_GR8))
    // 4: GPR 16-bit value.
    X3(PARTMAP(PMI_GR16))
};
#undef PARTMAP
#undef X3

unsigned SM83GenRegisterBankInfo::getRegBankBaseIdxOffset(unsigned RBIdx,
                                                          unsigned Size) {
  if (RBIdx != PMI_FirstGPR)
    return -1;

  switch (Size) {
  case 8:
    return PMI_GR8 - PMI_FirstGPR;
  case 16:
    return PMI_GR16 - PMI_FirstGPR;
  default:
    break;
  }

  return -1;
}

const RegisterBankInfo::ValueMapping *
SM83GenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx,
                                         unsigned Size) {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");
  unsigned BaseIdxOffset = getRegBankBaseIdxOffset(RBIdx, Size);
  if (BaseIdxOffset == -1u)
    return &ValMappings[InvalidIdx];

  unsigned ValMappingIdx =
      First3OpsIdx + (RBIdx - PartialMappingIdx::PMI_Min + BaseIdxOffset) *
                         ValueMappingIdx::DistanceBetweenRegBanks;
  assert(ValMappingIdx >= First3OpsIdx && ValMappingIdx <= Last3OpsIdx &&
         "Mapping out of bound");

  return &ValMappings[ValMappingIdx];
}

}
